백준 13925 - 수열과 쿼리 13 문제풀이
=

길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. 

* 1 x y v: Ai = (Ai + v) % MOD를 수행한다. (x ≤ i ≤ y)
* 2 x y v: Ai = (Ai × v) % MOD를 수행한다. (x ≤ i ≤ y)
* 3 x y v: Ai = v를 수행한다. (x ≤ i ≤ y)
* 4 x y: (ΣAi) % MOD를 출력한다. (x ≤ i ≤ y)

여기서 MOD는 항상 10^9+7이며, %는 나머지 연산을 의미한다.

- 첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)
- 둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 10^9)
- 셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)
- 넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ y ≤ N, 1 ≤ v ≤ 10^9)

<hr>

우선 range update / range query이기 때문에 Lazy propagation이 필요했다. 이는 옛날에 구현했던 코드를 가져와서 쉽게 틀을 만들어 놓았다.

특이하게 업데이트의 종류가 3가지인 문제였다. 처음엔 무식하게 long long 변수 3개를 가지고 있는 구조체를 만들어서 propagation을 3가지 따로 처리했고, 당연히 틀려서 계속 고치다보니 코드가 200줄이 넘어갔다 ㅋㅋ... lazy에 값이 쌓이면 순서가 보장이 되지 않는 것이 문제였고, queue를 이용해서 쿼리를 저장할까 생각도 해 보았지만 무조건 메모리 초과가 날 것 같았다.

3시간 쯤 지나서 결국 처음 시도한 방법으론 풀지 못했고, 힌트를 받아 문제를 단순화 했다.

핵심은 다음과 같다.

1. 3번 쿼리는 "2 x y 0" + "1 x y v" 와 같다. (0을 곱하고 v를 더하는 것 = v로 바꾸는 것). 즉 3번 쿼리는 따로 구현할 필요가 없고 lazy배열 역시 pair로 구현할 수 있다.
2. lazy를 쌓아갈 때, 곱하기 쿼리를 더하기 lazy에 적용해놓고, 해소시킬 때 곱하기 -> 더하기 순으로 하면 순서를 보장시킬 수 있다.

1번은 풀이를 생각하기 더 편하게 만들어 주는 것이고, 2번이 조금 헷갈리는데 예시를 하나 들자면, 

> * 배열 = $[1,2,3]$
> * 쿼리
>   - $2\,1\,3\,2$
>   - $1\,1\,3\,5$
>   - $2\,1\,2\,3$

라고 한다면, 배열의 변화는 아래와 같을 것이다.

> * $[1 \times 2, 2 \times 2, 3 \times 2]$
> * $[1 \times 2 + 5, 2 \times 2 + 5, 3 \times 2 + 5]$
> * $[(1 \times 2) \times 3 + 5 \times 3, (2 \times 2) \times 3 + 5 \times 3, (3 \times 2) + 5]$

Lazy를 도입해서 보면, (first -> 곱하기, second -> 더하기)

> * $Lazy.first = 2, Lazy.second = 0$
> * $Lazy.first = 2, Lazy.second = 5$
> * $Lazy.first = 6, Lazy.second = 15$

결국 더하기 쿼리는 다른 항이 추가되는 것이므로, 자신의 Lazy에 더하기만 해주면 되고, 곱하기 쿼리는 분배법칙이 적용되기 때문에 더하기 Lazy에도 곱해주는 것이다. 이후에 propagation을 수행할 시 곱하기 쿼리는 각 항의 원래 값에 바로 연결되어 있기 때문에 먼저 수행해야 하고, 더하기 쿼리는 이미 곱하기 쿼리가 적용된 값이 저장되어 있기 때문에 나중에 더해주면 깔끔하게 순서가 적용된다.

한 가지 디테일을 더 넣자면, 문제 조건에서는 들어오는 값이 최소 1이상이지만, 위의 규칙대로 3번 쿼리를 처리할 때 2번 쿼리에 0을 넣어서 초기화를 대체하기로 했으므로, 곱하기 Lazy의 디폴트 값을 1로 지정해놓으면 Lazy에 0이 있을 때 잘 처리가 된다. 사실 디폴트가 0이면 0검사를 해야 해서 그냥 1로 해놓고 푸는 것이 좋다. 

원래도 문제를 단순화하는것이 중요하다는 것은 알고 있었지만, 이번 문제를 풀면서 뼈저리게 느꼈다.